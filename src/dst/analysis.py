from __future__ import annotations

import json
import logging
from pathlib import Path

from dst.utils import default_to_regular, nested_defaultdict, safeget

logger = logging.getLogger(__name__)

SGD_VARIANTS = ("original", "v1", "v2", "v3", "v4", "v5")


def load_metrics(
    paths: list[Path], split: str, schema_variants: tuple[str] = SGD_VARIANTS
) -> list[dict]:
    """Load aggregated metrics output by the SGD evaluator, for each path. For each path, the function will recurse
    into the directories provided  as follows:

            - It will first look for directories specified in `schema_variants`. If such directories are found, \
            then the metrics for each decoding data format are loaded, and stored in the output dictionary as follows::

                {
                    'decoding_data_version': {'sgd_variant': metrics_dict, ...}, ...
                }

            where `metrics_dict` is the metrics dictionary output the by the SGD evaluator. `decoding_data_version`
            is a string indicating which prompt format was used for decoding and 'sgd_variant' is a member of
            `schema_variants`.

            - For all directories that are not in `schema_variants`, the loading function expects that the
            `schema_variants` directories are rooted in them, so the output dictionary will contain

                {
                    'dir_name':
                        {
                            'decoding_data_version': {'sgd_variant': metrics_dict, ...}, ...
                        }
                }

                for each directory name `dir_name` that is found by iterating through the contents of the directory
                rooted at path.

    Parameters
    ----------
    paths
        A list of paths for the metrics to be loaded.
    split
        Which split has been evaluated. Should be one of 'train', 'test', 'dev'.
    schema_variants
        Which SGD variants were evaluated. Defaults to ['original', 'v1', 'v2', 'v3', 'v4', 'v5']


    Returns
    -------
    A nested dict containing the metrics, with structure as described above.
     """

    metrics = []

    def load_metrics_file(metrics_path: Path) -> dict:
        metrics_files = list(metrics_path.glob("*.json"))
        if len(metrics_files) == 0:
            return
        if len(metrics_files) > 1:
            metric_file = metrics_files[-1]
            logging.info(
                f"Found multiple metrics files for path {metrics_path}, selected {metric_file}"
            )
        else:
            metric_file = metrics_files[0]
        with open(metric_file, "r") as f:
            data = json.load(f)
        return data

    for path in paths:
        this_pth_metrics = nested_defaultdict(dict, depth=3)
        for variant_dir in path.iterdir():
            variant = variant_dir.name
            if variant in schema_variants:
                if variant_dir.joinpath(split).exists():
                    versions = [p.name for p in variant_dir.joinpath(split).iterdir()]
                else:
                    versions = []
                for version in versions:
                    metrics_path = variant_dir.joinpath(split, version)
                    m = load_metrics_file(metrics_path)
                    if m is not None:
                        this_pth_metrics[version][variant] = m
            else:
                for v in schema_variants:
                    versions = [
                        p.name for p in variant_dir.joinpath(v, split).iterdir()
                    ]
                    for ver in versions:
                        metrics_path = variant_dir.joinpath(v, split, ver)
                        m = load_metrics_file(metrics_path)
                        if m is not None:
                            this_pth_metrics[ver][variant][v] = m
        metrics.append(default_to_regular(this_pth_metrics))
    return metrics


def get_version(ver: str) -> int:
    """Convert a string of format ``version_{digit}`` into an integer."""
    return int(ver.split("_")[1])


def get_average_metric_value(
    average_metrics: dict,
    experiment_name: str,
    decoding_data_version: str,
    decoding_strategy: str,
    domain_or_service: str,
    metric: str = "joint_goal_accuracy",
    schema_variants: tuple[str] = SGD_VARIANTS,
) -> dict[str, float]:
    """Retrieve a value of a metric from the nested dictionary data structure generated by `load_metrics` function."""

    def _format_service_for_variant(domain_or_service: str) -> str:
        nonlocal var  # SGD variant
        if "_" in domain_or_service and var != "original":
            return f"{domain_or_service}{var[-1]}"
        return domain_or_service

    result = {}
    for var in schema_variants:
        if get_version(decoding_data_version) > 7:
            store_key = [
                experiment_name,
                decoding_data_version,
                decoding_strategy,
                var,
                _format_service_for_variant(domain_or_service),
                metric,
            ]
        else:
            store_key = [
                experiment_name,
                decoding_data_version,
                var,
                _format_service_for_variant(domain_or_service),
                metric,
            ]
        value = safeget(average_metrics, *store_key)
        result[var] = value
    return result
